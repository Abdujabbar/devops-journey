import { Callout } from "nextra-theme-docs";

# Gitlab CI | Releaselar va Integrationlar

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/banner.png)

Tashkilotlarda loyiha kodlarni samarali saqlash va boshqarish asosiy vazifalardan biri hisoblanadi. Bugungi amaliyotimizda biz loyiha kodlarini qanday qilib versiyalash va roolback(ortga qaytish)ni yo'lga qo'yamiz. Jamoa bilan ishlash uchun bir nechta integratsiyalarni ko'rib chiqamiz, bu amaliyotda asosan notification integrationlarni ko'rib chiqamiz.

## Gitlab Releaselar

Loyilarni versiyalash va rollback qilish uchun biz Gitlab releaselardan foydalanamiz. Loyiha kodlarini samarali boshqarishning bir nechta usullari bor, barcha tashkilotlarning o'z kod saqlash srategiyalar bor, keling bu amalaiyotda bir loyiha kodlarini samarali manage qilishning bir usulini ko'rib chiqamiz.

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/git-architecture.png)

Rasmdagi kodni saqlash qarashni ko'rib chiqamiz:

* Barcha loyihlarda environmentga qarab asosiy branchlar bo'ladi misol uchun: **dev,test,prod**
* Barcha Dasturchilar guruhi loyihaning **dev** branchida ishlashadi va **dev** branch uchun **DEV** environmentga deploy bo'ladi.
* Loyihaning **TEST(yoki STAGE)** va **PROD** branchlariga to'gridan to'gri o'zgartirish kiritish mumkin bo'lmaydi faqat **DEV -> TEST -> PROD** qilib qadamma qadam prodga chiqish mumkin bo'ladi.
*  Stabil production kod **prod** yoki **main** branchda saqlanadi va shu branchlarda Release qilib kod versiyalanadi.


Keling loyiha kodlarini versiyalashni ko'rib chiqamiz. Biz misol uchun **main** branchga o'zgarish bo'lganda Gitlab release qilib loyiha kodlarini versiyalaydigan Gitlab CI yozamiz.

Ushbu amaliyotda biz [gitlab.com/ismoilovdev/devops-journey](https://gitlab.com/ismoilovdev/devops-journey) loyihasi misolida ko'rib chiqamiz. Keling birinchi navbatda branchlar ochib chiqamiz.

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab1.png)

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab2.png)

Rasmda ko'rsatilganidek **dev** va **stage** branchlar ochib olamiz **main** branchimiz esa prod chiqadigan branchimiz bo'ladi.

Loyihamiz branchlar ro'yxati, bu yerda main branch default branch hisoblanadi. 
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab3.png)

Keling default branchni main emas dev branchga o'zgartiramiz. Repositoriyaga kirib chap tomondan

 **Settings -> Repository -> Branch defaults**dan devga o'zgartirib qo'yamiz.

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab4.png)


## Gitlab CI

Loyihamiz Repositoriyasini sozlab olganimizdan keyin keling ikkita bosqichli Gitlab CI yozamiz yani **build** va **release**. Qachonki loyihamiz **main** branchida o'zgarish bo'lsa Gitlab CI pipelienmiz avtomatik ishga tushadi va loyihani build qilib keyin loyihani pipeline ID'si bilan versiyalab Release chiqaradi.

Gitlab Ci yozish uchun loyihamiz papkasida `.gitlab-ci.yml` CI pipeline fayl ochib olamiz. Mana bizning `gitlab-ci.yml` konfiguratsiyamiz.

```bash filename=".gitlab-ci.yml"
stages:
  - build
  - release

variables:
  NODE_VERSION: "20.x"

cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - node_modules/

before_script:
  - |
    if [[ "$CI_JOB_NAME" != *"release_job"* ]]; then
      apt-get update -qy
      apt-get install -y curl
      curl -sL https://deb.nodesource.com/setup_20.x | bash -
      apt-get install -y nodejs
      npm install -g pnpm
    fi

build:
  stage: build
  image: node:20
  script:
    - pnpm install
    - pnpm next build

release_job:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - echo "Running release_job for $TAG"
  release:
    tag_name: "v0.$CI_PIPELINE_IID"
    description: "v0.$CI_PIPELINE_IID"
    ref: "$CI_COMMIT_SHA"
``` 

Keling loyihamizda **.gitlab-ci.yml** konfigga shu **Gitlab CI** konfiguratsiyani qo'shib **main** branchga push qilamiz va bizd loyihamiz **main** branchiga o'tganimizda Gitlab CI pipeline ishlayotganini ko'rishimiz mumkin.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/ci.png)

Repositoriyamizdan **-> Build -> Pipelines**ga o'tib jarayonni kuzatishimiz mumkin.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/ci1.png)

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/ci4.png)

Okeyyy bizda Gitlab Ci pipelinemiz muvaffiqiyatli ishga tushdi, keling loyihani versiyalab reliz chiqarganini ko'rib chiqamiz.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/ci5.png)

Repositoriyamizga o'tib **Release** bo'limiga o'tamiz.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab5.png)

**Release**ga kirganimizda loyihamizda bitta **v0.1** tag bilan reliz chiqganini ko'rishimiz mumkin.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab6.png)

Okeyy kleing endi bu Gitlab CI pipelineni va vazifalarini ko'rib chiqamiz.

Bu qism ikkita stage bo'lishini belgilaydi ya'ni **build** va **release**
```bash
stages:
  - build
  - release
```

Bu qismda **variables** ga Nodejs **20.x** belgilanadi yani bu loyihani Nodejs **20.x** da ishga tushirishni bildiradi. **cache** qismi esa Nodejs loyihani ya'ni **node_modules/** papkani keshlashni bildiradi bu keyin CI larni tezlashtirishga yordam beradi.
```bash
variables:
  NODE_VERSION: "20.x"
 
cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - node_modules/
```
Bu qismda esa **before_script** Gitlab CI pipeline joblari ishga tuhsmasidan oldin ishga tushadigan qism hisoblanadi va NoeJS loyihani build qilish uchun runnerga NodeJS o'rnatib, pnpm ham o'rnatib loyihani build qilishga tayyor bo'ladi.
```bash
before_script:
  - |
    if [[ "$CI_JOB_NAME" != *"release_job"* ]]; then
      apt-get update -qy
      apt-get install -y curl
      curl -sL https://deb.nodesource.com/setup_20.x | bash -
      apt-get install -y nodejs
      npm install -g pnpm
    fi
```

Bu esa **build** bosqich hisoblanadi bu bosqichda **pnpm install** va **pnpm next build** buyruqlari yordamida Nodejs loyiha build qilinadi.
```bash
build:
  stage: build
  image: node:20
  script:
    - pnpm install
    - pnpm next build
```

Ushbu bosqich **release** bosqich hisoblanadi. Bu bosqichda `registry.gitlab.com/gitlab-org/release-cli:latest` docker imagedan foydalangan holda Release chiqariladi. Release faqat **main** branchda o'zgarish bo'lganidagina ishlaydi.
```bash
release_job:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - echo "Running release_job for $TAG"
  release:
    tag_name: "v0.$CI_PIPELINE_IID"
    description: "v0.$CI_PIPELINE_IID"
    ref: "$CI_COMMIT_SHA"
```

## Integrationlar

Tashkilotda loyihalarni samarali boshqarish va jamoa bilan ishlashni yaxshilash uchun har xil usullardan foydalaniladi, bulardan eng keng tarqagani Repositoriyalarga notification integratsiyalar hisoblanadi. Bugun biz Loyihlarimizga notification uchun Discord bilan inetgegratsiya qilamiz.


Keling birinchi o'rinda **Discord** sozlab olamiz.
Discord kirib **Add a Server** bosib Server yaratib olamiz

>![gitlab-ci](/images/tutorials/ci-cd/jenkins-docker/discord1.png)

>![gitlab-ci](/images/tutorials/ci-cd/jenkins-docker/discord2.png)

>![gitlab-ci](/images/tutorials/ci-cd/jenkins-docker/discord3.png)

Serverga nom berib **Create** bosamiz.

>![gitlab-ci](/images/tutorials/ci-cd/jenkins-docker/discord4.png)

Discord Server yaratib olganimzidan keyin Serverimizda channel yaratib olamiz. **Create Channel**

>![gitlab-ci](/images/tutorials/ci-cd/jenkins-docker/discord6.png)

Channel nomini yozamiz masalan **merge-requests** -> **Create Channel**
> ![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord.png)

Channel ochib olganimzidan keyin **Integrations** bo'limga kirib **Webhooks**dan **Create Webhook** bosamiz
> ![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord2.png)

**Webhook** yaratib olganimizdan keyin uni nusxalab **Copy Webhook URL** olib qo'yamiz va Gitlab **Discord Notification**da ishlatish  uchun olib qo'yamiz.
> ![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord3.png)


Discord Server ochib channellar ochib olganimizdan keyin G1itlabda Repositoriyaymizga o'tamiz va **-> Settings -> Integrations -> Discord Notifications** bo'limga o'tamiz.

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/gitlab7.png)

Integrations bo'limdan **Discord Notifications** bo'limga o'tamiz va **Configure** bosib konfiguratsiya bo'limiga o'tamiz.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord4.png)

Bu qismda Discord serverimizda yaratib olgan **Webhook**ni qo'shib qo'yamiz.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord5.png)

**Trigger** qismidan o'zimizni keraklisini sozlab olamiz. Bu holda yaxshi amaliyot bu har bir event uchun alohida Discord channel ochib uni webhookini Triggerga qo'shib chiqish kerak, Masalan Discord Serverda Merge Requests, Issue, Deployment status kabi Discord channellar ochib olinadi va quytidagi Trigger bo'limda kerakliu joylarga kerakli Discord channel webhook urllari qo'yib chiqiladi, shunda har bir event alohida Discord channelga keladi va ularni kuzatib manage qilish osonroq bo'ladi.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord7.png)

Bu qismda qaysi branchlar uchun notification kelishini belgilaymiz bu holda **All branches**. Konfiguratsiyani to'grilab chiqganimizdan keyin **Test settings** bosib konfiguratiya ishlashini tekshirib olamiz.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord6.png)

Konfiguratsiyamiz to'gri bo'lsa bizga Discord channelimizga quyidagicha test Notification keladi.
![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord8.png)

Keling endi **main** branchdagi kodga o'zgartirish kiritib commit qilamiz, bu holda yani Release chiqishi va Discordga Notification kelishi kerak.

![gitlab-ci](/images/tutorials/ci-cd/gitlabci-release-integrations/discord9.png)

Okeyy biz Repositoriyamizni muvaffiqiyatli ravishda Discord bilan integratsiya qildik. 
