import { Callout } from "nextra-theme-docs";

## Koddan Servergacha: Jenkins bilan Docker CI/CD va Discord bilan integratsiya

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/banner.png)


## Kirish
**Jenkins** - bu doimiy **C**ontinuous **I**ntegration/**C**ontinuous **D**eployment (**CI/CD**) pipelinei uchun ajoyib tool, ayniqsa Docker konteynerlari bilan ishlashda.

Jenkins **CI/CD** jarayonini osonlashtiradigan open-source avtomatlashtirish serveri boʻlib, ishlab chiquvchilarga applicationlarni build qilish, sinovdan oʻtkazish va deploymentni avtomatlashtirish imkonini beradi. Docker bilan birlashganda, u konteynerlashtirilgan workflowlari uchun kuchli yechim taklif qiladi, bu turli muhitlarda izchillik(consistency) va portativlikni ta'minlaydi.

Jenkins Docker bilan birgalikda izchil va samarali development workflowni yaratish uchun konteynerlashtirishdan foydalangan holda **CI/CD** jarayonini soddalashtiradi. Jenkins pipelinelarida Docker imkoniyatlaridan foydalanish orqali jamoalar dasturiy ta'minotni tezroq va ishonchli yetkazib berishga erishishlari mumkin. 

Bugun ushbu qo'llanmamizda konteynerlashtirilgan ilovalarni Jenkins orqali CI/CD avtomatizatsiya qilamiz.

Ushbu jarayon quyidagicha bosqichlarsan iborat bo'ladi. (qisqa tushuntirish)

* **CI** CI qismida biz loyiha source kodlari joylashgan github yoki gitlab bilan ishlaymiz. Github yoki Gitlabda yangi kod qo'shilsa Jenkins **CI** pipeline avtomatik ishga tushadigan qilamiz. Keyingi qismida o'zgarish bo'lganinidan keyin Github yoki Gitlabdan loyiha repositoriyasi va belgilangan branchdan loyiha source kodlarini runner yuklab oladi. Loyiah source kodlari yuklab olinganidan keyin test uchun Docker image build qilinadi, agara Docker image build bo'lsa keyingi bosqichda **CD** o'tadi aks holda shu joyida jarayon to'xtaydi. Docker image muvaffaqiyatli build bo'lganidan keyin birorta Docker Registryga push qilinadi. Shu jarayonlar hammasi bajarilganida **CI** bosqichimiz tugab **CD** bosqichiga o'tiladi.

* **CD** CI qismida applicationimiz testlardan o'tib Docker image build qilinib Docker Registyga push qilingan bo'ladi. CD qismida ssh orqali serverga kirib bundan oldingi docker containerni to'xtatib, o'chirib yangi docker imageni Docker Registydan pull qilib olib uni DOcker container qilib ishga tushirib qo'yishimiz kerak.

* **Notification** Agar CI/CD jarayoni muvaffaqiyatli yoki muvaffaqiyatsiz bo'lsa Discord serverga notification yuboradigan qilib Discord bilan integratsiya qilamiz.


## Ishni boshlash

Ushbu amaliyotni amalga oshirish uchun bizga quyidagi minimum server talablaridai server kerak bo'ladi.


<Callout type="info" emoji="">
**Minimum Server talabi**

| OS            | RAM            | CPU           | Xotira       | Static IP  |
| ------------- | -------------- | ------------- |------------- | ---------- |
| Ubuntu 20.04  | 8GB            | 4vCPU 2 core  | 50GB         | Ha kerak   |

**Tavsiya qilinadigan mimimum server talabi**

| OS            | RAM            | CPU           | Xotira       | Static IP  | Server nomi        |
| ------------- | -------------- | ------------- |------------- | ---------- | ------------------ |
| Ubuntu 20.04  | 4GB            | 4vCPU 2 core  | 50GB         | Ha kerak   | Jenkins Server     |
| Ubuntu 20.04  | 8GB            | 4vCPU 2 core  | 50GB         | Ha kerak   | Application Server |

</Callout>

Ushbu amaliyotda biz **Jenkins, Docker, Container Registry** (**Dockerhub** va **GCR**(**G**oogle **C**ontainer **R**egistry)), **Github** yoki **Gitlab, Discord** va **Ubuntu server** ishlatamiz

<Callout type="info" emoji="">
**ESLATMA->** Ushbu amaliyotda bi [**devops-journey**](https://github.com/ismoilovdevml/devops-journey) platformasi manba kodlaridan foydalanamiz. Stars(yulduzcha) bosib qo'yish esdan chiqmasin **:)**
</Callout>

## Jenkins o'rnatish

Amaliyotning birinchi qadami bu Serverga Jenkins o'rnatishdan boshlanadi. Bundan oldingi qo'llanmalarda Jenkins o'rnatish haqida yozilgan. [**Linux Serverlarga Jenkins o'rnatish**](https://devops-journey.uz/guides/ci-cd/jenkins-ornatish) qo'llanmasidan foydalanib seerveringizga jenkins o'rnatib olishingiz mumkin. Serveringizga Jenkins o'rnatib boshlang'ich sozlab olganiningzidan keyin keyingi bosqichga o'tsak bo'ladi.

## Docker o'rnatish

Biz ilovamizni Docker  containerlarda ishga tushiramiz shuning uchun serverimizga Docker o'rnatib olishmiz kerak bo'ladi. [**Linux serverlarga Docker o'rnatish**](https://devops-journey.uz/guides/konteyner/docker-ornatish) qo'llanasidan foydalanib sereveringizga Docker o'rnatib oling.

## Git bilan ishlash

Applicationlarimiz kodlarini birorta **VCS**(**V**ersion **C**ontrol **S**ystem)da saqlanadi ushbu amaliyotda **Github** va **Gitlab** bilan ishlaydigan Jenkins CI pipeline yozamiz. Gitdan private repositoriyalarni klon qilib olish uchun ushbu repositoriyalarga ruxsati bor userlardan **Personal access token** tokenlar olinadi va Jenkins credendialsga qo'shib qo'yiladi. Bundan maqsad Jenkins pipeline ushbu Personal access token orqali Github yoki Gitlabdan private repositoriyalarni clon qila olishi va ishlata olishidir.

<Callout type="info" emoji="">
**ESLATMA->** Ko'p startuplar kichik jamolar **Github** ishlatishadi, boshqalar esa enterprise **Gitlab**ni o'z seerverlarda ishga tuhsirib ishlatishadi. Bu amaliyotda 2lasi bilan ham ishlash yozilgan. Sizning jamoyingiz qaysi birini ishlatsa shunga mosini qo'llaysiz.
</Callout>

**Personal access token olish**

### Github uchun

Github profilingizga kirib **Settings** sozlamalar bo'limga kiring.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github1.png)

Keyin **Developer settings** bo'limga kiring.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github2.png)

**Personal access tokens** **->** **Tokens(classic)**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github3.png)

**->Generate new token(classic)**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github4.png)

**Personal access token**ga nom berib va ishlash mudatini belgilab admin accesslarni beramiz va **Generate token** bosib token generatsiya qilib olamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github5.png)

Sizga Github Personal access token generatsiya qilib beradinsiz uni nusxalab olib qo'yishingiz kerak bo'ladi. Bu Personal access tokenni Jenkinsda credentialsga qo'shib qo'yib Jenkins pipelineda ishlatamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github6.png)

### Gitlab uchun

Gitlab profilingizga kirib **Pereferences** bo'limga kirib **Accsess Tokens**ga o'tamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab1.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab2.png)

**Accsess Tokens**ga kirganimizdan keyin Token nomi ishlash muddatini belgilab kerakli ruxsatlarni berib **Create personal accsess token** bosib Gitlab token generatsiya qilib olamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab3.png)

O'zingiz ishlatdigan VCSdan access token generatsiya qilib olganingizdan keyin Serverimizda ishga tushirilgan Jenkinsga kirib credentialsga ushbu tokenlarni qo'shib qo'yamiz.

**->** `Manage Jenkins` **->** `Credentials`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins1.png)

**Username->** Gitlab yoki Github username

**Password** Gitlab yoki Gitlabdan genreatsiya qilib olgan personal access tokenni joylashtiramiz.

Jenkinsnga Gitlab yoki Githubdan private repositorilarni klon qilib ishlashi uchun accsess tokenni joylashtiurib sozlaganimizdan keyin birinchi Jenkins CI pipelineni yozsak bo'ladi.

## Discord bilan integratsiya

Discordni CI/CD pipelinelari bilan integratsiyalash dastuchilar guruhlari ichida hamkorlik va aloqani yaxshilaydi. Discord, mashhur xabar almashish platformasi, real vaqt rejimida notificationlar uchun markazlashtirilgan markaz(hub) bo'lib xizmat qiladi, tezkor javob vaqtlarini oshiradi va dasturiy ta'minotni ishlab chiqishning lifecyclini yaxshilaydi. Jenkins CI yoki har qanday CI/CD tooli Discord bilan bog'lash orqali dasturchilar to'g'ridan-to'g'ri o'zlari tanlagan Discord kanallarida build holati, test natijalari va deployment natijalari bo'yicha tezkor yangilanishlarni oladi. 

Qisqa qilib aytganda biz discordni CI/CD pipelinemiz muvaffaqiyatli ishini tugatgani yoki muvaffaqiyatsiz bo'lgan xabarlarni dasturchilar guruhlariga discord orqali yetkizish uchun ishlatamiz.

### Jenkins uchun
Discordni Jenkins bilan integratsiya qilish uchun **Discord Notifier** plagini Jenkinsga o'rnatib olishimiz kerak.

**->** `Manage Jenkins` **->** `Plugins` **->** `Available plugins`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins3.png)

**Discord Notifier** plaghini o'rnatilib jenkins restart bo'lganidan keyin Discord server ochib serverda channel ochib webhook yaratib olamiz.

Discord kirib **Add a Server** bosib Server yaratib olamiz

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord1.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord2.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord3.png)

Serverga nom berib **Create** bosamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord4.png)

Discord Server yaratib olganimzidan keyin Serverimizda channel yaratib olamiz. **Create Channel**

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord6.png)

Channel nomini yozamiz masalan **dev-jenkins** -> **Create Channel**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord7.png)

Channel ochib olganimzidan keyin **Integrations** bo'limga kirib **Webhooks**dan **Create Webhook** bosamiz
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord8.png)

**Webhook** yaratib olganimizdan keyin uni nusxalab **Copy Webhook URL** olib qo'yamiz va Jenkins pipelineda ishlatish  uchun olib qo'yamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord9.png)

Discordan olgan webhookni Jenkins credendialsga qo'shamiz.

**->** `Manage Jenkins` **->** `Credentials`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins4.png)

### Gitlab Github uchun

Github bilan jenkinsni integratsiya qilish uchun ushbu video qo'llanmalardan foydalanishingiz mumkin. **dev-jenkins** channel ochtganimizdek github yoki gitlab channel ochib webhook yaratib Gitlab yoki Github bilan integratsiya qilamiz.

Bu holda har bir repositorilarga discord webhook ulab chiqiladi.
* [**Githubga discord ulash**](https://youtu.be/-KDQqWNK3Tw?si=6S_8Jq3KZjzubOKh)

* [**Gitlabga discord ulash**](https://docs.gitlab.com/ee/user/project/integrations/discord_notifications.html)

## Birinchi CI pipeline

Hozirchi hammasi tayyor birinchi Jenkins CI pipelinemizni yozishga tayyormiz. Jenkinsga kirib loyihamiz uchun job yaratib olamiz.

**-> Creaet a job +**

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job1.png)

**Enter an item name** ga loyihamiz nomini yozib **Pipeline**ni tanlab **OK** bosamiz

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job2.png)

Keyingi qismda eng pastgi qatorga **Pipeline** qismiga quyidagi birinchi CI pipelinemizni joylashtiramiz **Save** qilamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job3.png)

**Jenkins CI pipeline**

```groovy {5-8,13,18,24-30}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```
Keling pipelineni bo'laklarga bo'lib ko'rib chiqamiz. Bu **Groovy**-da yozilgan Jenkins Pipeline, Java Virtual Machine uchun skript tili. Keling, ushbu pipelinening asosiy qismlarini ajratamiz:

```groovy
agent any
```
Ushbu pipeline Jenkins muhitida mavjud bo'lgan har qanday agentda ishlashi mumkin. Har qanday kalit so'z pipelineni istalgan mavjud executorda ishlashiga imkon beradi.

```groovy
environment {
    DISCORD_WEBHOOK = credentials('discord-webhook')
    GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
    GIT_TOKEN = credentials('git-token')
    BRANCH_NAME = 'main'
}
```

* **DISCORD_WEBHOOK->** Discord webhook URL manzilini saqlaydigan credential.
* **GIT_URL->** Klonlanadigan Git repositoriyaning URL manzili.
* **GIT_TOKEN->** Autentifikatsiya uchun Git tokenini saqlaydigan credendial(private repositorilar bilan ishlash uchun).
* **BRANCH_NAME->** Git repositoriyasining foydalaniladigan branchi (bu holda main).

```groovy
stages {
    stage('Clean Workspace') {
        steps {
            cleanWs()
        }
    }
    stage('Clone Repository') {
        steps {
            git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
        }
    }
}
```
* **Clean Workspace->** Ushbu bosqich ishni boshlashdan oldin workspaceni tozalaydi.
* **Clone Repository->** Bu bosqich **GIT_URL** va **BRANCH_NAME** tomonidan belgilangan Git repositoriyani **git-token*** tomonidan aniqlangan credendial yordamida klonlaydi.

```groovy
post {
    always {
        discordSend(
            description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
            link: env.GIT_URL,
            result: currentBuild.currentResult,
            title: JOB_NAME,
            webhookURL: env.DISCORD_WEBHOOK
        )
    }
}
```
Jarayon tugallangandan so'ng (muvaffaqiyatsiz bo'lsa ham), **discordSend** qadami bajariladi. U **DISCORD_WEBHOOK** da saqlangan webhook URL manzilidan foydalanib, Discord channelga notification(xabar) yuboradi. Xabarda natija, Git omboriga havola va job nomi kabi ma'lumotlar mavjud.

Qisqa qilib aytganda ushbu boshlang'ich sodda pipeline ishga tushganida biinchi **Clean Workspace** bosqichida **cleanWs()** bilan worskspaceni tozalaydi keyingi **Clone Repository** bosqichida berilgan **GIT_URL**, **GIT_TOKEN** va **BRANCH_NAME** bilan Git repositoriyani klon qilib oladi. Oxirgi bosqichda pipeline muvaffaqiyatli(**SUCCSES**) yoki muvaffaqiyatsiz(**FAILED**) bo'lgani haqida Discord channelga notification(xabar) yuboradi.

Keling pipelineni ishga tushiramiz. **-> Build Now**

> ![netflix](/images/article/netflix/jenkins5.png)

SIzda quyidagi natijha bilan muvaffaqiyatli ishga tushishi va discordga notification yuborilishi kerak.

> ![netflix](/images/tutorials/ci-cd/jenkins-docker/job4.png)

> ![netflix](/images/tutorials/ci-cd/jenkins-docker/discord10.png)

## Git repositoriyalar bilan ishlash (mono repo va multi repo)

Bizda har xil vaziyat bo'lishi mumkin loyihamiz mono repo yoki multi repo bo'lishi mumkin.

**Monorepo (Monolithic Repository)->** `monolithic repository` so'zining qisqartmasi **monorepo** - bu bir nechta loyihalar, applicationlar yoki servicelar bitta repositoriyada saqlanadigan version control system (VCS) strategiyasidir. Monorepoda barcha kodlar, kutubxonalar(library) va turli loyihalar uchun dependensilar(bog'liqliklar) bitta markaziy repositoriyada birgalikda boshqariladi. Ushbu yondashuv har bir loyiha yoki servicening o'z repositoriyasiga ega bo'lgan ko'p repositoriyali(multi-repo) sturukturasidan farq qiladi. Qisqa qilib aytganda butun bir tashkilot loyilari bitta repositoriyada bo'ladi.

**Multirepo (Multi-Repository)->** multi-repo yondashuvida har bir loyiha, application yoki service o'zining alohida repositoriyasiga ega. Har bir repositoriya ma'lum bir kod bazasi yoki servicega bag'ishlangan va loyihalar o'rtasidagi dependensilar versiya va paketlarni boshqarish orqali boshqariladi. Qisqa qilib ayganda har bir loyiha, application, service va boshqalar alohida alohida repositoriyalarda bo'ladi va bir-biriga bo'g'liklari bo'ladi.

**Monorepo** va **multirepo** yondashuvlarining kuchli va zaif tomonlari bor va ular orasidagi tanlov ko'pincha loyiha yoki tashkilotning o'ziga xos ehtiyojlari, ko'lami va rivojlanish ish oqimlariga bog'liq.


Agar biz CI/CD yozayotgan loyiha monorepo bo'lsa, bitta monoreponi o'zini clon qilib uni build qilib ishga tushira olamiz, Bu soddaroq bo'ladi chunki loyihalar, applicationlar, servicelar va boshqalar o'rtasidagi bo'gliklik(reference) bitta shu monorepo ichida bo'ladi.

Monorepo uchun Jenkins pipeline, faqat kerakli monorepo clon qilinadi holos.

```groovy {16-20}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```

Tashkilot loyihlari multirepo bo'lsa va biz loyihalarga CI/CD yozayotgan bo'lsak, har bir loyihada bir nechta boshqa repositoriyalarga bo'glikligi(reference) bo'ladi, shuning uchun CI/CD yozayotgan loyihamiz ishlashiga kerak bo'lgan loyiha, application,service va boshqalar repositoriyalarni ham klon qilib olishimiz va yig'ishimiz kerak bo'ladi. 

Multirepo uchun Jenkins pipeline.

```groovy {6-9, 20-40}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        API_GIT_URL ='https://github.com/ismoilovdevml/devops-journey-api.git'
        UI_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-ui.git'
        SERVICE_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-service.git'
        CONFIGURATIONS_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-configurations.git'
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Setup Environment') {
            steps{
                    dir('configurations'){
                        git branch: BRANCH_NAME, url: CONFIGURATIONS_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/devops-journey-ui'){
                        git branch: BRANCH_NAME, url: UI_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/devops-journey-api'){
                        git branch: BRANCH_NAME, url: API_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/devops-journey-service'){
                        git branch: BRANCH_NAME, url: SERVICE_GIT_URL, credentialsId: 'git-token'
                    }
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/MAIN.Dockerfile ./MAIN.Dockerfile"
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/API.Dockerfile ./API.Dockerfile"
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/UI.Dockerfile ./UI.Dockerfile" 
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/SERVICE.Dockerfile ./SERVICE.Dockerfile" 
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
````

Multirepo uchun yozgan pipelinemizda o'zgarishlar quyidagicha **devops-journey** loyihamizda bir nechta boshqa repositoriyalarga bo'gliklari mavjuda maslaan UI, API, Service va Configurations repositoriyalarga. Ushbu loyihani Jenkins CI/CD ishga tushirihsimiz uchun ushbu repositoriyalar clon qilinb yig'ishimiz va birga ishga tushirishimiz kerak. **Setup Environment** qadami ushbu vazifani bajaradi yani Environmentni sozlaydi kerak repositoriyalarni bir joyga yig'adi.

Ushbu namunada konfiguratsiyalar ham alohida repositoriyada saqlanagnmi ko'rsatilgan yani **configurations** repositoriyada barcha loyihalar servicelar applicationlar konfiglari(masalan Dockerfayllar) branchlar nomi bilan joylashtirgan bo'ladi. **configurations** repositoriyasi tuzulishga namuna.


```bash
├── configurations
│   └── devops-journey
│       ├── main
│       │   ├── API.Dockerfile
│       │   ├── MAIN.Dockerfile
│       │   ├── SERVICE.Dockerfile
│       │   └── UI.Dockerfile
│       ├── dev
│       │   ├── API.Dockerfile
│       │   ├── MAIN.Dockerfile
│       │   ├── SERVICE.Dockerfile
│       │   └── UI.Dockerfile
│       ├── stage
│       │   ├── API.Dockerfile
│       │   ├── MAIN.Dockerfile
│       │   ├── SERVICE.Dockerfile
│       │   └── UI.Dockerfile
│       └── prod
│           ├── API.Dockerfile
│           ├── MAIN.Dockerfile
│           ├── SERVICE.Dockerfile
│           └── UI.Dockerfile
```

## CI pipeline

Hammasi tayyor endi to'liq CI pipeline yozib ishga tuhsirsak bo'ladi. Bundan oldin monorepo va multi-repolar bilan ishlash ko'rsatildi loyihangizga qarab buni tanlaysiz. [**devops-journey**](https://github.com/ismoilovdevml/devops-journey) monorepo bo'lgani uchun monorepo CI/CD pipeline yozamiz lekin yuqorida multi-repo uchun ko'rsatilgan.

Hozirgacha yozgan CI pipelinemiz quyidagicha

```groovy
pipeline {
    agent any
 
    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```

**CI** pipelinemizga Docker bilan ishlash bosqichini qo'shimiz kerak. Buning uchun Jenkinsga kerakli plaginlarni o'rnatib olishimiz kerak.

Pipelinemizda Docker bilan ishlash uchun quyidagi plaginlarni o'rnatib olishimiz kerak.

`Docker`, `Docker Common`, `Docker Pipeline`, `Docker API`, `docker-build-step`

> ![netflix](/images/article/netflix/docker1.png)

Plaginlarni o'rnatib bo'lganingizdan keyin sozlab chiqish kerak. 

**->** `Manage Jenkins` **->** `Tools` **->** `Docker installations`

> ![netflix](/images/article/netflix/docker2.png)

 Docker bilan ishlashni sozlab chiqganimizdan keyin Jenkins pipelineda build bo'lgan docker imagelarni push qilish saqlash uchun Docker Registry ishlatamiz. Ushbu amaliyotda **Dockerhub** va **GCR**(**G**oogle **C**ontainer **R**egistry)dan foydalanish ko'rsatiladi. Dockerhub bepul versiyasida bitta private docker imagega ruxsat bor undan keyingi imagelar avtomatik public bo'ladi, private qilish uchun Dockerhub pullik obunga a'zo bo'lish kerak. **GCR** Google Cloudga tegishli.

### Dockerhub

Amaliyotni ushbu qismida **Docker Registry** uchun **Dockerhub** ishlatamiz shuning uchun Dockerhubdan ro'yxatdan o'tgan bo'lishingiz  va Access token olgan bo'lishingiz kerak.
Agar Ro'yxatdan o'tmagan bo'lsangiz ro'yxatdan o'tishingiz kerak

> ![netflix](/images/article/netflix/docker3.png)

`Sign up` bosib ro'yxatdan o'tasiz 

> ![netflix](/images/article/netflix/docker4-new.png)

Ro'yxatdan o0'tib olganingizdan keyin **Email Verification** talab qilinadi. Email verifatsiya qilganingizdan keyin 

**->** `Account Settings` **->** `Security` **->** bo'limga o'tib `Access Token` yaratib olamiz.

> ![netflix](/images/article/netflix/docker5.png)

> ![netflix](/images/article/netflix/docker6.png)

Access Tokenga nom berib unga **Read,Write,Delete** permisonlarni beramiz **`Generate`** qilamiz.

> ![netflix](/images/article/netflix/docker7.png)

Sizga access token generatsiya qilib berialdi va siz undan nusxa olib qo'yishingiz kerak, aks holda uni qaytib ololmaysiz. Sizga docker login qilish uchun namuna CLI command ham beriladi 

```bash
docker login -u devsecopsuser4732
```
Jenkins pipelineda DockerHub Registrydan foydalanishimiz uchun Jenkins crdentialsga DockerHub user va tokenni qo'shib qo'yamiz.

**->** `Manage Jenkins` **->** `Credentials`-ga kirib  `Add credentials`ga o'tamiz.


> ![netflix](/images/article/netflix/secret6.png)

**Username**ga DockerHub usernamengizni yozasiz **Password**ga esa yuqorida yaratib olgan access tokenimizni joylashtiramiz.

Dockerhubdan ro'yxatdan o'tdik, access token oldik hammasini Jenkins credentialsga **dockerhub** ID bilan saqladik endi Jenkins pipelinega **CD**(continuous delivery)qismini qo'shsak bo'ladi.

Jenkins pipelenimizga quyidagi bosqichni qo'shamiz. Bu bosqich ilovamizdan docker image yaratib, build qilib, Docker Registyga push qiladi ya'ni DockerHubga.

Pipelinega yangi environmentlar qo'shib olamiz:

```groovy {4-6}
environment {
    DISCORD_WEBHOOK = credentials('discord-webhook')
    GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
    DOCKERHUB_CREDENTIALS = credentials('dockerhub')
    CONTAINER_NAME = 'devops-journey'
    REGISTRY_URL = 'devsecopsuser732'
    GIT_TOKEN = credentials('git-token')
    BRANCH_NAME = 'main'
}
```
* **DOCKERHUB_CREDENTIALS ->** credentialsdandan DockerHub username va access tokenni olib keladi.
* **CONTAINER_NAME ->** Bu loyihamizni containerda ishga tushirishda unga beriladigan nom
* **REGISTRY_URL ->** Dokcer Registry URL. Bizni holatimizda yani Dockerhubda bu yerda Dockerhub username yoziladi.

Dockerhub bilan ishlaydigan Jenkins **CI** pipelienmiz quyidagicha yangilaymiz.

```groovy {7-9,24-42}
pipeline {
    agent any
 
    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        DOCKERHUB_CREDENTIALS = credentials('dockerhub')
        CONTAINER_NAME = 'devops-journey'
        REGISTRY_URL = 'devsecopsuser732'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
        stage('Build Application') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'dockerhub', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    script {
                        def dockerlogin = "docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
                        sh dockerlogin
                        sh """
                            docker build . -t ${REGISTRY_URL}/${CONTAINER_NAME}:${BUILD_NUMBER} -f Dockerfile
                            docker tag ${REGISTRY_URL}/${CONTAINER_NAME}:${BUILD_NUMBER} ${REGISTRY_URL}/${CONTAINER_NAME}:latest
                            docker push ${REGISTRY_URL}/${CONTAINER_NAME}:latest
                            docker push ${REGISTRY_URL}/${CONTAINER_NAME}:${BUILD_NUMBER}
                            docker image rm -f ${REGISTRY_URL}/${CONTAINER_NAME}:latest
                            docker image rm -f ${REGISTRY_URL}/${CONTAINER_NAME}:${BUILD_NUMBER}
                        """
                    }
                }    
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```

### GCR(Google Container Registry)

Docker Registry sifatida **GCR** ishlatish uchun Google Cloud **IAM**dan **Service Account** ochihb olishimiz va unga **Storage Admin** ruxsatini berishimiz kerak, undan keyin service accountga kirib service accoun key generatsiya qilib olishimiz kerak. Credentiallar Jenkins pipeline Google cloudga GCR ga kira olishi va ishlashi uchun kerak.

**1->** Google Cloudga kirib **Service Accounts**dan service account yaratib olamiz.

**-> Google Cloud -> IAM & Admin -> Service Accounts**

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp1.png)

**+ CREATE SERVICE ACCOUNT** bosib service account yaratib olamiz.

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp2.png)

**Service account name**ga service accountimiz uchun nom yozamiz masalan **gcr. Service account description**ga esa description yozib **DONE** bosganimizdan keyin keyingi bosqichga o'tadi
![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp3.png)

**Role**ga **Storage Admin** huquqini beramiz va **DONE** bosib yaratib olamiz.
![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp4.png)

Service Account yaratib olganimizdan keyin Service Accountimizga(gcr) kirib **KEYS** qismidan **ADD KEY** bosib **JSON** formatda private key generatsiya qilib olamiz va uni yuklab olamiz.


**-> KEYS -> ADD KEY -> JSON -> CREATE**
![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp5.png)

Yuklab olgan Service accoun  private keyimizni Jenkins credentialsga qo'shib qo'yamiz.

**->** `Manage Jenkins` **->** `Credentials`-ga kirib  `Add credentials`ga o'tamiz.

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp6.png)

Google Clouddan yuklab olgan service accoun private keyimizni ochib ko'rsak 2chi qatorida **project_id** ko'rsatilgan bo'ladi uni nusxalab olib uni ham Jenkins credentialsga qo'shib qo'yamiz.

**->** `Manage Jenkins` **->** `Credentials`-ga kirib  `Add credentials`ga o'tamiz.

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gcp7.png)

Hamma kerakli keylarni Jenkins credentialsga qo'shagnimizdan keyin bizni Jenkins pipelinemizda quyidaicha o'zgarishlar bo'ladi.

```groovy {7-10,28-45}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GCR_CREDENTIALS = credentials('gcr-key')
        GCP_PROJECT_ID = credentials('gcp-project-id')
        CONTAINER_NAME = 'devops-journey'
        REGISTRY_URL = 'gcr.io'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }

    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: GIT_TOKEN
            }
        }

        stage('Build and Push Docker Image') {
            steps {
                script {
                    def dockerImage = "${REGISTRY_URL}/${GCP_PROJECT_ID}/${CONTAINER_NAME}:${BUILD_NUMBER}"

                    sh """
                        cat ${GCR_CREDENTIALS} | docker login -u _json_key --password-stdin https://gcr.io
                        docker build . -t ${dockerImage} -f Dockerfile
                        docker push ${dockerImage}
                        docker tag ${dockerImage} ${REGISTRY_URL}/${GCP_PROJECT_ID}/${CONTAINER_NAME}:latest
                        docker push ${REGISTRY_URL}/${GCP_PROJECT_ID}/${CONTAINER_NAME}:latest
                        docker image rm -f ${dockerImage}
                        docker image rm -f ${REGISTRY_URL}/${GCP_PROJECT_ID}/${CONTAINER_NAME}:latest
                    """
                }
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: DISCORD_WEBHOOK
            )
        }
    }
}
```