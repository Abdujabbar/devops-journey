import { Callout } from "nextra-theme-docs";

## Koddan Servergacha: Jenkins bilan Docker CI/CD va Discord bilan integratsiya

![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/banner.png)


## Kirish
**Jenkins** - bu doimiy **C**ontinuous **I**ntegration/**C**ontinuous **D**eployment (**CI/CD**) pipelinei uchun ajoyib tool, ayniqsa Docker konteynerlari bilan ishlashda.

Jenkins **CI/CD** jarayonini osonlashtiradigan open-source avtomatlashtirish serveri boʻlib, ishlab chiquvchilarga applicationlarni build qilish, sinovdan oʻtkazish va deploymentni avtomatlashtirish imkonini beradi. Docker bilan birlashganda, u konteynerlashtirilgan workflowlari uchun kuchli yechim taklif qiladi, bu turli muhitlarda izchillik(consistency) va portativlikni ta'minlaydi.

Jenkins Docker bilan birgalikda izchil va samarali development workflowni yaratish uchun konteynerlashtirishdan foydalangan holda **CI/CD** jarayonini soddalashtiradi. Jenkins pipelinelarida Docker imkoniyatlaridan foydalanish orqali jamoalar dasturiy ta'minotni tezroq va ishonchli yetkazib berishga erishishlari mumkin. 

Bugun ushbu qo'llanmamizda konteynerlashtirilgan ilovalarni Jenkins orqali CI/CD avtomatizatsiya qilamiz.

Ushbu jarayon quyidagicha bosqichlarsan iborat bo'ladi. (qisqa tushuntirish)

* **CI** CI qismida biz loyiha source kodlari joylashgan github yoki gitlab bilan ishlaymiz. Github yoki Gitlabda yangi kod qo'shilsa Jenkins **CI** pipeline avtomatik ishga tushadigan qilamiz. Keyingi qismida o'zgarish bo'lganinidan keyin Github yoki Gitlabdan loyiha repositoriyasi va belgilangan branchdan loyiha source kodlarini runner yuklab oladi. Loyiah source kodlari yuklab olinganidan keyin test uchun Docker image build qilinadi, agara Docker image build bo'lsa keyingi bosqichda **CD** o'tadi aks holda shu joyida jarayon to'xtaydi. Docker image muvaffaqiyatli build bo'lganidan keyin birorta Docker Registryga push qilinadi. Shu jarayonlar hammasi bajarilganida **CI** bosqichimiz tugab **CD** bosqichiga o'tiladi.

* **CD** CI qismida applicationimiz testlardan o'tib Docker image build qilinib Docker Registyga push qilingan bo'ladi. CD qismida ssh orqali serverga kirib bundan oldingi docker containerni to'xtatib, o'chirib yangi docker imageni Docker Registydan pull qilib olib uni DOcker container qilib ishga tushirib qo'yishimiz kerak.

* **Notification** Agar CI/CD jarayoni muvaffaqiyatli yoki muvaffaqiyatsiz bo'lsa Discord serverga notification yuboradigan qilib Discord bilan integratsiya qilamiz.


## Ishni boshlash

Ushbu amaliyotni amalga oshirish uchun bizga quyidagi minimum server talablaridai server kerak bo'ladi.


<Callout type="info" emoji="">
**Minimum Server talabi**

| OS            | RAM            | CPU           | Xotira       | Static IP  |
| ------------- | -------------- | ------------- |------------- | ---------- |
| Ubuntu 20.04  | 8GB            | 4vCPU 2 core  | 50GB         | Ha kerak   |

**Tavsiya qilinadigan mimimum server talabi**

| OS            | RAM            | CPU           | Xotira       | Static IP  | Server nomi        |
| ------------- | -------------- | ------------- |------------- | ---------- | ------------------ |
| Ubuntu 20.04  | 4GB            | 4vCPU 2 core  | 50GB         | Ha kerak   | Jenkins Server     |
| Ubuntu 20.04  | 8GB            | 4vCPU 2 core  | 50GB         | Ha kerak   | Application Server |

</Callout>

Ushbu amaliyotda biz **Jenkins, Docker, Container Registry** (**Dockerhub** va **GCR**(**G**oogle **C**ontainer **R**egistry)), **Github** yoki **Gitlab, Discord** va **Ubuntu server** ishlatamiz

## Jenkins o'rnatish

Amaliyotning birinchi qadami bu Serverga Jenkins o'rnatishdan boshlanadi. Bundan oldingi qo'llanmalarda Jenkins o'rnatish haqida yozilgan. [**Linux Serverlarga Jenkins o'rnatish**](https://devops-journey.uz/guides/ci-cd/jenkins-ornatish) qo'llanmasidan foydalanib seerveringizga jenkins o'rnatib olishingiz mumkin. Serveringizga Jenkins o'rnatib boshlang'ich sozlab olganiningzidan keyin keyingi bosqichga o'tsak bo'ladi.

## Docker o'rnatish

Biz ilovamizni Docker  containerlarda ishga tushiramiz shuning uchun serverimizga Docker o'rnatib olishmiz kerak bo'ladi. [**Linux serverlarga Docker o'rnatish**](https://devops-journey.uz/guides/konteyner/docker-ornatish) qo'llanasidan foydalanib sereveringizga Docker o'rnatib oling.

## Git bilan ishlash

Applicationlarimiz kodlarini birorta **VCS**(**V**ersion **C**ontrol **S**ystem)da saqlanadi ushbu amaliyotda **Github** va **Gitlab** bilan ishlaydigan Jenkins CI pipeline yozamiz. Gitdan private repositoriyalarni klon qilib olish uchun ushbu repositoriyalarga ruxsati bor userlardan **Personal access token** tokenlar olinadi va Jenkins credendialsga qo'shib qo'yiladi. Bundan maqsad Jenkins pipeline ushbu Personal access token orqali Github yoki Gitlabdan private repositoriyalarni clon qila olishi va ishlata olishidir.

<Callout type="info" emoji="">
**ESLATMA->** Ko'p startuplar kichik jamolar **Github** ishlatishadi, boshqalar esa enterprise **Gitlab**ni o'z seerverlarda ishga tuhsirib ishlatishadi. Bu amaliyotda 2lasi bilan ham ishlash yozilgan. Sizning jamoyingiz qaysi birini ishlatsa shunga mosini qo'llaysiz.
</Callout>

**Personal access token olish**

### Github uchun

Github profilingizga kirib **Settings** sozlamalar bo'limga kiring.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github1.png)

Keyin **Developer settings** bo'limga kiring.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github2.png)

**Personal access tokens** **->** **Tokens(classic)**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github3.png)

**->Generate new token(classic)**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github4.png)

**Personal access token**ga nom berib va ishlash mudatini belgilab admin accesslarni beramiz va **Generate token** bosib token generatsiya qilib olamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github5.png)

Sizga Github Personal access token generatsiya qilib beradinsiz uni nusxalab olib qo'yishingiz kerak bo'ladi. Bu Personal access tokenni Jenkinsda credentialsga qo'shib qo'yib Jenkins pipelineda ishlatamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/github6.png)

### Gitlab uchun

Gitlab profilingizga kirib **Pereferences** bo'limga kirib **Accsess Tokens**ga o'tamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab1.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab2.png)

**Accsess Tokens**ga kirganimizdan keyin Token nomi ishlash muddatini belgilab kerakli ruxsatlarni berib **Create personal accsess token** bosib Gitlab token generatsiya qilib olamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/gitlab3.png)

O'zingiz ishlatdigan VCSdan access token generatsiya qilib olganingizdan keyin Serverimizda ishga tushirilgan Jenkinsga kirib credentialsga ushbu tokenlarni qo'shib qo'yamiz.

**->** `Manage Jenkins` **->** `Credentials`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins1.png)

**Username->** Gitlab yoki Github username

**Password** Gitlab yoki Gitlabdan genreatsiya qilib olgan personal access tokenni joylashtiramiz.

Jenkinsnga Gitlab yoki Githubdan private repositorilarni klon qilib ishlashi uchun accsess tokenni joylashtiurib sozlaganimizdan keyin birinchi Jenkins CI pipelineni yozsak bo'ladi.

## Discord bilan integratsiya

Discordni CI/CD pipelinelari bilan integratsiyalash dastuchilar guruhlari ichida hamkorlik va aloqani yaxshilaydi. Discord, mashhur xabar almashish platformasi, real vaqt rejimida notificationlar uchun markazlashtirilgan markaz(hub) bo'lib xizmat qiladi, tezkor javob vaqtlarini oshiradi va dasturiy ta'minotni ishlab chiqishning lifecyclini yaxshilaydi. Jenkins CI yoki har qanday CI/CD tooli Discord bilan bog'lash orqali dasturchilar to'g'ridan-to'g'ri o'zlari tanlagan Discord kanallarida build holati, test natijalari va deployment natijalari bo'yicha tezkor yangilanishlarni oladi. 

Qisqa qilib aytganda biz discordni CI/CD pipelinemiz muvaffaqiyatli ishini tugatgani yoki muvaffaqiyatsiz bo'lgan xabarlarni dasturchilar guruhlariga discord orqali yetkizish uchun ishlatamiz.

### Jenkins uchun
Discordni Jenkins bilan integratsiya qilish uchun **Discord Notifier** plagini Jenkinsga o'rnatib olishimiz kerak.

**->** `Manage Jenkins` **->** `Plugins` **->** `Available plugins`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins3.png)

**Discord Notifier** plaghini o'rnatilib jenkins restart bo'lganidan keyin Discord server ochib serverda channel ochib webhook yaratib olamiz.

Discord kirib **Add a Server** bosib Server yaratib olamiz

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord1.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord2.png)

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord3.png)

Serverga nom berib **Create** bosamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord4.png)

Discord Server yaratib olganimzidan keyin Serverimizda channel yaratib olamiz. **Create Channel**

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord6.png)

Channel nomini yozamiz masalan **dev-jenkins** -> **Create Channel**
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord7.png)

Channel ochib olganimzidan keyin **Integrations** bo'limga kirib **Webhooks**dan **Create Webhook** bosamiz
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord8.png)

**Webhook** yaratib olganimizdan keyin uni nusxalab **Copy Webhook URL** olib qo'yamiz va Jenkins pipelineda ishlatish  uchun olib qo'yamiz.
>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/discord9.png)

Discordan olgan webhookni Jenkins credendialsga qo'shamiz.

**->** `Manage Jenkins` **->** `Credentials`

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/jenkins4.png)

### Gitlab Github uchun

Github bilan jenkinsni integratsiya qilish uchun ushbu video qo'llanmalardan foydalanishingiz mumkin. **dev-jenkins** channel ochtganimizdek github yoki gitlab channel ochib webhook yaratib Gitlab yoki Github bilan integratsiya qilamiz.

Bu holda har bir repositorilarga discord webhook ulab chiqiladi.
* [**Githubga discord ulash**](https://youtu.be/-KDQqWNK3Tw?si=6S_8Jq3KZjzubOKh)

* [**Gitlabga discord ulash**](https://docs.gitlab.com/ee/user/project/integrations/discord_notifications.html)

## Birinchi CI pipeline

Hozirchi hammasi tayyor birinchi Jenkins CI pipelinemizni yozishga tayyormiz. Jenkinsga kirib loyihamiz uchun job yaratib olamiz.

**-> Creaet a job +**

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job1.png)

**Enter an item name** ga loyihamiz nomini yozib **Pipeline**ni tanlab **OK** bosamiz

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job2.png)

Keyingi qismda eng pastgi qatorga **Pipeline** qismiga quyidagi birinchi CI pipelinemizni joylashtiramiz **Save** qilamiz.

>![docker-ci-cd](/images/tutorials/ci-cd/jenkins-docker/job3.png)

**Jenkins CI pipeline**

```groovy {5-8,13,18,24-30}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```
Keling pipelineni bo'laklarga bo'lib ko'rib chiqamiz. Bu **Groovy**-da yozilgan Jenkins Pipeline, Java Virtual Machine uchun skript tili. Keling, ushbu pipelinening asosiy qismlarini ajratamiz:

```groovy
agent any
```
Ushbu pipeline Jenkins muhitida mavjud bo'lgan har qanday agentda ishlashi mumkin. Har qanday kalit so'z pipelineni istalgan mavjud executorda ishlashiga imkon beradi.

```groovy
environment {
    DISCORD_WEBHOOK = credentials('discord-webhook')
    GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
    GIT_TOKEN = credentials('git-token')
    BRANCH_NAME = 'main'
}
```

* **DISCORD_WEBHOOK->** Discord webhook URL manzilini saqlaydigan credential.
* **GIT_URL->** Klonlanadigan Git repositoriyaning URL manzili.
* **GIT_TOKEN->** Autentifikatsiya uchun Git tokenini saqlaydigan credendial(private repositorilar bilan ishlash uchun).
* **BRANCH_NAME->** Git repositoriyasining foydalaniladigan branchi (bu holda main).

```groovy
stages {
    stage('Clean Workspace') {
        steps {
            cleanWs()
        }
    }
    stage('Clone Repository') {
        steps {
            git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
        }
    }
}
```
* **Clean Workspace->** Ushbu bosqich ishni boshlashdan oldin workspaceni tozalaydi.
* **Clone Repository->** Bu bosqich **GIT_URL** va **BRANCH_NAME** tomonidan belgilangan Git repositoriyani **git-token*** tomonidan aniqlangan credendial yordamida klonlaydi.

```groovy
post {
    always {
        discordSend(
            description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
            link: env.GIT_URL,
            result: currentBuild.currentResult,
            title: JOB_NAME,
            webhookURL: env.DISCORD_WEBHOOK
        )
    }
}
```
Jarayon tugallangandan so'ng (muvaffaqiyatsiz bo'lsa ham), **discordSend** qadami bajariladi. U **DISCORD_WEBHOOK** da saqlangan webhook URL manzilidan foydalanib, Discord channelga notification(xabar) yuboradi. Xabarda natija, Git omboriga havola va job nomi kabi ma'lumotlar mavjud.

Qisqa qilib aytganda ushbu boshlang'ich sodda pipeline ishga tushganida biinchi **Clean Workspace** bosqichida **cleanWs()** bilan worskspaceni tozalaydi keyingi **Clone Repository** bosqichida berilgan **GIT_URL**, **GIT_TOKEN** va **BRANCH_NAME** bilan Git repositoriyani klon qilib oladi. Oxirgi bosqichda pipeline muvaffaqiyatli(**SUCCSES**) yoki muvaffaqiyatsiz(**FAILED**) bo'lgani haqida Discord channelga notification(xabar) yuboradi.

Keling pipelineni ishga tushiramiz. **-> Build Now**

> ![netflix](/images/article/netflix/jenkins5.png)

SIzda quyidagi natijha bilan muvaffaqiyatli ishga tushishi va discordga notification yuborilishi kerak.

> ![netflix](/images/tutorials/ci-cd/jenkins-docker/job4.png)

> ![netflix](/images/tutorials/ci-cd/jenkins-docker/discord10.png)

## Git repositoriyalar bilan ishlash (mono repo va multi repo)

Bizda har xil vaziyat bo'lishi mumkin loyihamiz mono repo yoki multi repo bo'lishi mumkin.

**Monorepo (Monolithic Repository)->** `monolithic repository` so'zining qisqartmasi **monorepo** - bu bir nechta loyihalar, applicationlar yoki servicelar bitta repositoriyada saqlanadigan version control system (VCS) strategiyasidir. Monorepoda barcha kodlar, kutubxonalar(library) va turli loyihalar uchun dependensilar(bog'liqliklar) bitta markaziy repositoriyada birgalikda boshqariladi. Ushbu yondashuv har bir loyiha yoki servicening o'z repositoriyasiga ega bo'lgan ko'p repositoriyali(multi-repo) sturukturasidan farq qiladi. Qisqa qilib aytganda butun bir tashkilot loyilari bitta repositoriyada bo'ladi.

**Multirepo (Multi-Repository)->** multi-repo yondashuvida har bir loyiha, application yoki service o'zining alohida repositoriyasiga ega. Har bir repositoriya ma'lum bir kod bazasi yoki servicega bag'ishlangan va loyihalar o'rtasidagi dependensilar versiya va paketlarni boshqarish orqali boshqariladi. Qisqa qilib ayganda har bir loyiha, application, service va boshqalar alohida alohida repositoriyalarda bo'ladi va bir-biriga bo'g'liklari bo'ladi.

**Monorepo** va **multirepo** yondashuvlarining kuchli va zaif tomonlari bor va ular orasidagi tanlov ko'pincha loyiha yoki tashkilotning o'ziga xos ehtiyojlari, ko'lami va rivojlanish ish oqimlariga bog'liq.


Agar biz CI/CD yozayotgan loyiha monorepo bo'lsa, bitta monoreponi o'zini clon qilib uni build qilib ishga tushira olamiz, Bu soddaroq bo'ladi chunki loyihalar, applicationlar, servicelar va boshqalar o'rtasidagi bo'gliklik(reference) bitta shu monorepo ichida bo'ladi.

Monorepo uchun Jenkins pipeline, faqat kerakli monorepo clon qilinadi holos.

```groovy {16-20}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Clone Repository') {
            steps {
                git branch: BRANCH_NAME, url: GIT_URL, credentialsId: 'git-token'
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
```

Tashkilot loyihlari multirepo bo'lsa va biz loyihalarga CI/CD yozayotgan bo'lsak, har bir loyihada bir nechta boshqa repositoriyalarga bo'glikligi(reference) bo'ladi, shuning uchun CI/CD yozayotgan loyihamiz ishlashiga kerak bo'lgan loyiha, application,service va boshqalar repositoriyalarni ham klon qilib olishimiz va yig'ishimiz kerak bo'ladi. 

Multirepo uchun Jenkins pipeline.

```groovy {6-9, 20-40}
pipeline {
    agent any

    environment {
        DISCORD_WEBHOOK = credentials('discord-webhook')
        API_GIT_URL ='https://github.com/ismoilovdevml/devops-journey-api.git'
        UI_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-ui.git'
        SERVICE_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-service.git'
        CONFIGURATIONS_GIT_URL = 'https://github.com/ismoilovdevml/devops-journey-configurations.git'
        GIT_URL = 'https://github.com/ismoilovdevml/devops-journey.git'
        GIT_TOKEN = credentials('git-token')
        BRANCH_NAME = 'main'
    }
    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
        stage('Setup Environment') {
            steps{
                    dir('configurations'){
                        git branch: BRANCH_NAME, url: CONFIGURATIONS_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/ui'){
                        git branch: BRANCH_NAME, url: UI_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/api'){
                        git branch: BRANCH_NAME, url: API_GIT_URL, credentialsId: 'git-token'
                    }
                    dir('devops-journey/service'){
                        git branch: BRANCH_NAME, url: SERVICE_GIT_URL, credentialsId: 'git-token'
                    }
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/MAIN.Dockerfile ./MAIN.Dockerfile"
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/API.Dockerfile ./API.Dockerfile"
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/UI.Dockerfile ./UI.Dockerfile" 
                    sh "cp configurations/devops-journey/${BUILD_BRANCH}/SERVICE.Dockerfile ./SERVICE.Dockerfile" 
            }
        }
    }
    post {
        always {
            discordSend(
                description: "Jenkins Pipeline Build ${currentBuild.currentResult}",
                link: env.GIT_URL,
                result: currentBuild.currentResult,
                title: JOB_NAME,
                webhookURL: env.DISCORD_WEBHOOK
            )
        }
    }
}
````

Multirepo uchun yozgan pipelinemizda o'zgarishlar quyidagicha **devops-journey** loyihamizda bir nechta boshqa repositoriyalarga bo'gliklari mavjuda maslaan UI, API, Service va Configurations repositoriyalarga. Ushbu loyihani Jenkins CI/CD ishga tushirihsimiz uchun ushbu repositoriyalar clon qilinb yig'ishimiz va birga ishga tushirishimiz kerak. **Setup Environment** qadami ushbu vazifani bajaradi yani Environmentni sozlaydi kerak repositoriyalarni bir joyga yig'adi.

Ushbu namunada konfiguratsiyalar ham alohida repositoriyada saqlanagnmi ko'rsatilgan yani **configurations** repositoriyada barcha loyihalar servicelar applicationlar konfiglari(masalan Dockerfayllar) branchlar nomi bilan joylashtirgan bo'ladi. **configurations** repositoriyasi tuzulishga namuna.


```bash
├── main
│   ├── API.Dockerfile
│   ├── MAIN.Dockerfile
│   ├── SERVICE.Dockerfile
│   └── UI.Dockerfile
├── dev
│   ├── API.Dockerfile
│   ├── MAIN.Dockerfile
│   ├── SERVICE.Dockerfile
│   └── UI.Dockerfile
├── stage
│   ├── API.Dockerfile
│   ├── MAIN.Dockerfile
│   ├── SERVICE.Dockerfile
│   └── UI.Dockerfile
├── prod
│   ├── API.Dockerfile
│   ├── MAIN.Dockerfile
│   ├── SERVICE.Dockerfile
│   └── UI.Dockerfile
```

