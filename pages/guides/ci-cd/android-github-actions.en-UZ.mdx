import { Callout } from "nextra-theme-docs";

# Github Actions bilan Anroid CI/CD

![android](/images/tutorials/ci-cd/android-cicd/banner.png)

Mobil applicationlarni ishlab chiqaradigan katta jamolarda ishlarni avtomatlashtirish uchun CI/CD pipelinelar ishlab chiqadilar. Bugun biz Android applicationlar uchun Github Actions bilan CI/CD yozamiz o'ylaymanki bu ko'pchilik mobil dasturchilar uchun qiziqarli va foydali bo'ladi. Bugun CI/CD biz Android applarda har xil testlar qilasiz kodni analiz qilamiz Android release qilamiz va oxirida Google Play Storega deploy qilamiz. Notificationlar uchun Githubni Discord bilan inetegratsiya qilamiz. ushbu qo'llanmda biz kod analiz uchun **Sonarqube**, Test uchun esa **JUnit** ishlatamiz.


## Discord bilan integratsiya

Biz loyihamizni discord bilan integratsiya qilish uchun `Discord webhook` dan foydalanamiz. Discord bilan integratsiya qilishda Discord server ochib olishimiz va serverda channel ochishimiz kerak. 

<Callout type="info" emoji="">
Discord channel ochish va Discord webhook olib Githubdagi loyiha bilan integratsiya qilish bo'yicha quyidagi [video qo'llanmani](https://youtu.be/-KDQqWNK3Tw?si=L8YYPAX4RKVi1ACa) ko'rib chiqishingiz mumkin.
</Callout>

## Android CI

Har doimgidek CI/CD yozishni birinchi bo'lib CI yozishdan boshlaymiz. Birinchi navbatda loyihamiz root papkasida **.github** papka ochib ichida yana **workflows** papka ochib unda **android-ci.yml** ochib olamiz.

Keling birinchi oddiy **Android CI** yozamiz uni vazifasi kerakli dasturlarni o'rnatik APK build qiladi.

```bash
name: Build and Release APK

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build_and_release:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew
        
      - name: Build APK
        run: ./gradlew assembleRelease
```
Keling ushbu oddiy **Andorid CI** konfiguratsiyani yozib **main** branchga push qilamiz. Repositoriyamizga **android-ci.yml** konfiguratsiyamizni **main** branchga push qilganimizdan keyin repositoriyamiz **Actions** bo'limiga o'tib jarayonni kuzatishimiz mumkin.

![android](/images/tutorials/ci-cd/android-cicd/actions1.png)

Okey bizda jarayon muvaffaqiyatli yakunlandi.
![android](/images/tutorials/ci-cd/android-cicd/actions2.png)

Endi keling ushbu kichik **Andorid CI** tuzulishini qanday ishlashini ko'rib chiqamiz, undan keyin keyingi bosqichlarga o'tsak bo'ladi.

```bash
name: Build and Release APK

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
```

Ushbu qismda birinchi qator Action nomini belgilaydi bu holda bizda **Build and Release APK** bo'ladi. Keyingi  Belgilangan qism esa **Trigger** deb nomlanadi, ya'ni loyihamiz repositoriyasi **main** branchga commit bo'lib o'zgarish bo'lganida va yoki pull request kelib tushganda avtomatik Github Actions ishga tushishini bildiradi.


```bash
jobs:
  build_and_release:
    runs-on: ubuntu-latest
```
Bu qismda **build_and_release** nomli bitta **job** ochiladi va u **ubuntu-latest** runnerda ishga tushishini bildiradi.

```bash
- name: Checkout Repository
  uses: actions/checkout@v4
```
Bu qism [actions/checkout@v4](https://github.com/actions/checkout) orqali loyiha kodlarni runnerda klon qilib oladi.

```bash
- name: Setup JDK 17
  uses: actions/setup-java@v2
  with:
    java-version: '17'
    distribution: 'adopt'
```

Ushbu qismda **ubuntu-latest** runnerga [actions/setup-java@v2](https://github.com/actions/setup-java) orqali Java **JDK 17 adopt** distributioni o'rnatadi.

```bash
- name: Grant execute permission for gradlew
  run: chmod +x ./gradlew
```
Gradle orqali APK buil qilishimiz uchun **gradlew** executeb qilish permissionni beramiz.

```bash
- name: Build APK
  run: ./gradlew assembleRelease
```
Gradle yordamida APK buil qilamiz.

Yuqorida biz oddiy, sodda Android CI yozdik keling endi Andorid CI'ni kengaytiramiz.

```bash
name: Android CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  cache-gradle:
    name: Cache Gradle dependencies
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Cache Gradle
        uses: actions/cache@v2
        with:
          path: ~/.gradle/caches
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}
          restore-keys: ${{ runner.os }}-gradle-
```
**android-ci.yml** konfiguratsiyamizni quyidagi yangilaymiz. ushbu yangilashda biz keyingi CI'lar tezroq ishlashi uchun [actions/cache@v2](https://github.com/actions/cache) yordamida Gradle keshlashni sozladik. Ushbu CI qismda biz matrix usuldan foydalanamiz va bir nechta boshqichlar qo'shamiz bular quyidagilar:


* **-> Cache Gradle dependencies**
* **-> Perform lint check**
* **-> Perform Unit Testing**
* **-> Perform Instrumentation Testing**
* **-> Generate Debug APK**
* **-> Perform static code analysis**

### Perform lint check

**-> Cache Gradle dependencies** bosqichidan keyin undan keyingi bosqichlar parallel ishga tusha boshlaydi. Ushbu **Perform lint check** bosqichi Android loyihani lint check qilib kodlarni tekshirishdan iborat. Ushbu bosqich ubuntu-latest runnerda ishlaydi va  birinchi qadami gradle keshlarini olishdan boshlanadi, keyin [actions/checkout@v4](https://github.com/actions/checkout) orqali loyiha kodlarini klon qilib oladi, JDK 17 o'rnatadi runnerda muhitni sozlab oladi. `gradlew` ga chmod +x qilib execute permission beriladi va `./gradlew lintDebug` buyrug'i orqali lint check boshlandi. Lin check report html faylda bo'lib  `app/build/reports/lint-results-debug.html` joylashgan bo'ladi biz bu reportni [actions/upload-artifact@v2](https://github.com/actions/upload-artifact) orqali `lint.html` qilib Github Actions artifatlarga yuklab qo'yamiz.

```bash {18-19,21-25}
  lint:
    name: Perform lint check
    needs: [cache-gradle]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Make Gradle executable
        run: chmod +x ./gradlew

      - name: Run lint
        run: ./gradlew lintDebug

      - name: Upload html test report
        uses: actions/upload-artifact@v2
        with:
          name: lint.html
          path: app/build/reports/lint-results-debug.html
```

### Perform Unit Testing

Ushbu bosqichda Android loyihamizga yozilgan *Unit Test**larni ishga tushirib loyihani test qiladi. **Unit Test** reportlar `pp/build/reports/test/testDebugUnitTest/` joylashgab bo'ladi va biz uni [actions/upload-artifact@v2](https://github.com/actions/upload-artifact) orqali `unit_test_report.zip` qilib Github Actions artifatlarga yuklab qo'yamiz.
```bash {15-16, 18-22}
unit-test:
  name: Perform Unit Testing
  needs: [cache-gradle]
  runs-on: ubuntu-latest
  steps:
    - name: Checkout the code
      uses: actions/checkout@v4

    - name: Set up Java JDK 17
      uses: actions/setup-java@v2
      with:
        java-version: '17'
        distribution: 'adopt'

    - name: Run tests
      run: ./gradlew test

    - name: Upload test report
      uses: actions/upload-artifact@v2
      with:
        name: unit_test_report
        path: app/build/reports/test/testDebugUnitTest/
```

### Perform Instrumentation Testing

Bu bosqichda Android applicationimizda **Instrumentation Test, Espresso**larni, ishga tushiradi. 

**Espresso** - bu Android applicationlar uchun **UI** testlarini yozish uchun keng qo'llaniladigan test tizimi. U Android applicationning foydalanuvchi interfeysidagi elementlarning xatti-harakatlari bilan o'zaro aloqada bo'lish va tasdiqlash uchun fluent API taqdim etadi. **ubuntu-latest** runnerda Espresso testlarini ishga tushirish uchun [reactivecircus/android-emulator-runner@v2](https://github.com/ReactiveCircus/android-emulator-runner) yordamida **API leveli  29** bo'lgan Android emulator o'natiladi va `./gradlew connectedCheck` buyrug'i yordamida o'rnatilgan android emulatorda Espresso testlari ishga tushira boshlanadi. Instrumentation Test reportlari `app/build/reports/androidTests/connected` joylashgan bo'ladi biz uni `instrumentation_test_report.zip` qilib  Github Actions artifactlarga yuklaymiz.

```bash {15-19,21-25}
instrumentation-test:
  name: Perform Instrumentation Testing
  needs: [cache-gradle]
  runs-on: macos-latest
  steps:
    - name: Checkout the code
      uses: actions/checkout@v4

    - name: Set up Java JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'adopt'

    - name: Run espresso tests
      uses: reactivecircus/android-emulator-runner@v2
      with:
        api-level: 29
        script: ./gradlew connectedCheck

    - name: Upload Instrumentation Test report
      uses: actions/upload-artifact@v2
      with:
        name: instrumentation_test_report
        path: app/build/reports/androidTests/connected
```

### Generate Debug APK

Bu bosqichda biz debug APK build qilamiz. **ubuntu-latest** runnerda APK build qilish uchun envrironment sozlab olingandan keyin  `./gradlew assembleDebug --stacktrace` buyrug'i yordamida debug APK build qilamiz. Debug APK `app/build/outputs/apk/debug/app-debug.apk`da joylashgan bo'ladi biz uni **sample-app.apk** qilib Github Actions artifactlarga yuklab qo'yamiz

```bash {15-16,18-22}
debug-apk:
  name: Generate Debug APK
  needs: [cache-gradle]
  runs-on: ubuntu-latest
  steps:
    - name: Checkout the code
      uses: actions/checkout@v4

    - name: Set up Java JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'adopt'

    - name: Build debug APK
      run: ./gradlew assembleDebug --stacktrace

    - name: Upload APK
      uses: actions/upload-artifact@v2
      with:
        name: sample-app.apk
        path: app/build/outputs/apk/debug/app-debug.apk
```

Ushbu qismda bizning to'liq **android-ci.yml** Github Actions CI pipelinemiz quyidagicha.

```bash {10-22, 24-48,50-71,73-97, 99-120}
name: Android CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  cache-gradle:
    name: Cache Gradle dependencies
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Cache Gradle
        uses: actions/cache@v2
        with:
          path: ~/.gradle/caches
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle') }}
          restore-keys: ${{ runner.os }}-gradle-

  lint:
    name: Perform lint check
    needs: [cache-gradle]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Make Gradle executable
        run: chmod +x ./gradlew

      - name: Run lint
        run: ./gradlew lintDebug

      - name: Upload html test report
        uses: actions/upload-artifact@v2
        with:
          name: lint.html
          path: app/build/reports/lint-results-debug.html

  unit-test:
    name: Perform Unit Testing
    needs: [cache-gradle]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Run tests
        run: ./gradlew test

      - name: Upload test report
        uses: actions/upload-artifact@v2
        with:
          name: unit_test_report
          path: app/build/reports/test/testDebugUnitTest/

  instrumentation-test:
    name: Perform Instrumentation Testing
    needs: [cache-gradle]
    runs-on: macos-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Run espresso tests
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          script: ./gradlew connectedCheck

      - name: Upload Instrumentation Test report
        uses: actions/upload-artifact@v2
        with:
          name: instrumentation_test_report
          path: app/build/reports/androidTests/connected

  debug-apk:
    name: Generate Debug APK
    needs: [cache-gradle]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the code
        uses: actions/checkout@v4

      - name: Set up Java JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Build debug APK
        run: ./gradlew assembleDebug --stacktrace

      - name: Upload APK
        uses: actions/upload-artifact@v2
        with:
          name: sample-app.apk
          path: app/build/outputs/apk/debug/app-debug.apk
```

Ushbu Android CI'ni **main** branchga push qilamiz u avtomatik ishga tushadi va biz jarayoni repositoriyamiz **Actions** bo'limidan kuzatishimiz mumkin.

![android](/images/tutorials/ci-cd/android-cicd/actions3.png)

Okeey bizda barcha **Anroid CI** bosqichlar muvaffaqiyatli o'z ishini tugatdi.
![android](/images/tutorials/ci-cd/android-cicd/actions4.png)
**Artifats** bo'limiga o'tsak bizda artifactga yuklagan artifactlarimizni ko'rishimiz mumkin.
![android](/images/tutorials/ci-cd/android-cicd/actions5.png)

Keling **instrumentation_test_report** va **lint.html** artifactlarni yuklab olamiz bizga .zip arxivda yuklab olamiz bularni arxivdan chiqarib olib  **index.html** faylini brauzer orqali ochamiz, shunda biz reportlarni ko'rishimiz mumkin.
![android](/images/tutorials/ci-cd/android-cicd/report3.png)

**Perform Instrumentation Testing** reportlari.
![android](/images/tutorials/ci-cd/android-cicd/report1.png)
**Perform lint check** reportlari.
![android](/images/tutorials/ci-cd/android-cicd/report2.png)

### Perform static code analysis

Ushbu bosqichda biz kodni sifatini aniqlash uchun static kod analizlardan foydalanamiz bu holda bizda **SonarQube**.

**SonarQube** kod sifatini tekshirish va statik tahlil qilish vositalaridir. Ular muammolarni erta aniqlash, kodlash standartlarini joriy etish, xavfsizlik zaifliklarini aniqlash, texnik debtlarni boshqarish va fikr-mulohazalar uchun CI/CD pipelinelar bilan integratsiyalashuv orqali yuqori sifatli kodni ta'minlaydi. Ushbu toollar dasturiy ta'minot loyihalarida kod sifati, xavfsizligi va barqarorligini ta'minlash uchun zarurdir.

Biz ushbu loyiha uchun **SonarCloud**dan foydalanamiz. 

**1-> [sonarcloud.io](https://sonarcloud.io/login)**'dan Github orqali ro'yxatdan o'tamiz.
![android](/images/tutorials/ci-cd/android-cicd/sonarqube.png)

**2->** Github orqali ro'yxatdan o'tganimizdan keyin organizatsiya import qilamiz **-> Import an organization**
![android](/images/tutorials/ci-cd/android-cicd/sonarqube1.png)

**3-> Import an organization** bosganimzidan keyin SonarClodni qaysi repositoriyalarga yoki barcha repositoriyalarga o'rnatishni so'raydi, siz hohlsangiz bitta repositoriyaga yoki barcha repositoriyalarni tanlab SonarCloudni o'rnatishingiz mumkin.
![android](/images/tutorials/ci-cd/android-cicd/sonarcloud2.png)

**4->** Organizatsiya import qilinganidan keyin sizdan organizatsiya sozlash oynasi ochiladi siz organizatsiya nomini va unga keyini yozib kiritasiz va plan tanlaysiz bu iushbu amaliyot uchun free(bepul) planni tanlab ishlaymiz lekin free planda faqat public repositoriyalarda SonarCloudni ishlata olasiz. Agar siz SonarQubeni private repositorilar uchun ham ishlatmochi bo'lsangiz **SonarQube Community Edition**ni serveringizga o'rnatib olib ishlatishingiz mumkin.
![android](/images/tutorials/ci-cd/android-cicd/sonarcloud3.png)
![android](/images/tutorials/ci-cd/android-cicd/sonarcloud4.png)

**5->** Bu qismda biz repositoriyamizni tanlaymiz va **Set Up** bosib keyingi SonarCloudni belgilangan repositoriya o'rnatamiz.
![android](/images/tutorials/ci-cd/android-cicd/sonarcloud5.png)

**6->** Ushbu qismdan biz har safar Githubgagi loyihamiz kodlari o'zgarganda kod analiz ishlashini tanlaymiz.

![android](/images/tutorials/ci-cd/android-cicd/sonarcloud6.png)
Va bizda quyidagi oyna ochiladi.
![android](/images/tutorials/ci-cd/android-cicd/sonarcloud7.png)

Okeey hozir biz loyiahmiz uchun SonarCloud sozlab oldik keling endi uni ishlashini test qilib sinab ko'ramiz. Github repositoriyamizda birorta o'zgartirish qilib **main** branchga push qilamiz va bizda **SonarCloud CI** ishlashi kerak.

Github Actionsda ko'rganimizda bizda **SonarCloud Code Analysis** muvaffaqiyatli ishlaganini ko'rishimiz mumkin.
![android](/images/tutorials/ci-cd/android-cicd/actions6.png)

Okeey Github Actionsda SonarCloud ishladi keling buni SonarCloud o'zida ham tekshirib ko'ramiz.
![android](/images/tutorials/ci-cd/android-cicd/report4.png)
![android](/images/tutorials/ci-cd/android-cicd/report5.png)


Okeey hammasi zo'r biz **Android CI**bi shu yerda to'xtatamiz va keyingi bosqichga ya'ni **Android CD**'ga o'tamiz.

### Android CD