---
image: https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/banner.png
description: "Java Spring Boot Deployment: Gitlab CI va Github Actions"
---

import { Callout } from "nextra-theme-docs";

# Java Spring Boot Deployment: Gitlab CI va Github Actions

![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/banner.png)


Ushbu qo'llanma **Java Spring Boot** applicationlarnni **GitLab CI/CD** va **GitHub Actions** yordamida avtomatlashtirilgan tarzda deploy qilishni o'rganishni maqsad qilgan. Bu amaliyot DevOps Engineerlar va Java dasturchilari uchun zarur bo'lgan bilim va ko'nikmalarni qamrab oladi. Qo'llanmada Java Spring Boot applicationining tuzilishini tushunish va konfiguratsiya qilish jarayonlari ko'rib chiqamiz.

Shuningdek, biz Dockerfile yozishni o'rganamiz va uni samarali ishlashi uchun optimallashtiramiz. Docker asosida konteynerlash jarayonlarini o'zlashtirgach, GitLab CI/CD va GitHub Actions yordamida CI/CD pipeline'larini sozlash va avtomatlashtirish usullarini ko'rib chiqamiz.

Ushbu qo'llanma orqali siz Java Spring Boot applicationlari uchun CI/CD jarayonlarini muvaffaqiyatli amalga oshirish bo'yicha amaliy yondashuvga ega bo'lasiz va real loyihalarda bu usullarni qo'llash imkoniyatiga ega bo'lasiz.

<Callout type="info" emoji="">
Ushbu amaliyotda quyidagi Java Spring Boot application kodlaridan foydalanamiz - [**gitlab.com/ismoilovdev/waifulist**](https://gitlab.com/ismoilovdev/waifulist)
</Callout>


## Loyihani tushunish

Spring Boot loyihasini muvaffaqiyatli deploy qilish uchun dastlab uning tuzilishini, ishlash prinsipini va muhim konfiguratsiyalarini to'liq tushunish lozim.
Spring Boot loyihasi asosan quyidagi tarkibiy qismlardan iborat:

Masalan bizning loyihamiz tuzulishi:

```
/waifulist
├── Dockerfile
├── HELP.md
├── LICENSE
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── zawkin
    │   │       └── me
    │   │           └── asuna
    │   │               ├── config
    │   │               │   └── SwaggerConfig.java
    │   │               ├── controller
    │   │               │   └── WaifuController.java
    │   │               ├── dto
    │   │               │   └── WaifuDTO.java
    │   │               ├── entity
    │   │               │   └── WaifuEntity.java
    │   │               ├── repository
    │   │               │   └── WaifuRepository.java
    │   │               ├── service
    │   │               │   └── WaifuService.java
    │   │               └── WaifulistApplication.java
    │   └── resources
    │       └── application.properties
    └── test
        └── java
            └── zawkin
                └── me
                    └── asuna
                        └── WaifulistApplicationTests.java
```

`src/main/java/zawkin/me/asuna` katalogida loyihaning asosiy Java fayllari joylashgan. `WaifulistApplication.java` fayli Spring Boot applicationning asosiy dastur kodi hisoblanadi.

```java filename="WaifulistApplication.java"
package zawkin.me.asuna;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WaifulistApplication {

	public static void main(String[] args) {
		SpringApplication.run(WaifulistApplication.class, args);
	}

}
```
@SpringBootApplication` anotatsiyasi Spring Boot applicationning asosiy konfiguratsiyalarini o'z ichiga oladi. `main` metodida esa application ishga tushiriladi.

`src/main/resources` katalogida esa applicationning konfiguratsiyalarini saqlash uchun fayllar joylashgan. Bu katalogda `application.properties` yoki `application.yml` joylashadi. Bizning loyihamizda `application.properties` fayli mavjud.

```properties filename="application.properties"
spring.application.name=waifulist

# DATABASE
spring.datasource.url=jdbc:postgresql://134.209.217.179:5432/waifulist
spring.datasource.username=postgres
spring.datasource.password=lwfjljqwotpreqwt2
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

logging.level.org.springframework.web=DEBUG
logging.level.org.springdoc=DEBUG
```

`application.properties` faylida applicationning konfiguratsiyalarini saqlash uchun kerak bo'lgan sozlamalar joylashgan. Masalan, `spring.datasource.url` sozlamasi PostgreSQL bazasiga ulanish uchun kerak bo'lgan ma'lumotlarni saqlaydi.

`pom.xml` yoki `build.gradle` fayllari dependencylar, pluginlar va boshqa loyihaning konfiguratsiyalarini saqlaydi. Bizning loyihamizda `pom.xml` fayli mavjud, ya'ni Maven loyihasi agar `build.gradle` fayli mavjud bo'lsa Gradle loyihasi deb hisoblanadi.


`src/test/java/zawkin/me/asuna` katalogida loyihaning test fayllari joylashgan. `WaifulistApplicationTests.java` fayli Spring Boot applicationning test kodi hisoblanadi.

```java filename="WaifulistApplicationTests.java"
package zawkin.me.asuna;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class WaifulistApplicationTests {

	@Test
	void contextLoads() {
	}

}
```

Spring Boot loyihasini muvaffaqiyatli ishlashi uchun `application.properties` yoki `application.yml` fayllari muhim ahamiyatga egadir. Applicationning barcha konfiguratsiyalarini bu fayllar orqali o'zgartirish mumkin. Masalan bizning loyihamizdagi `properties` konfiguratsiya faylini ko'rib chiqamiz.

```properties filename="application.properties"
spring.application.name=waifulist

# DATABASE
spring.datasource.url=jdbc:postgresql://134.209.217.179:5432/waifulist
spring.datasource.username=postgres
spring.datasource.password=lwfjljqwotpreqwt2
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

logging.level.org.springframework.web=DEBUG
logging.level.org.springdoc=DEBUG
```
Bu xavsfzilik uchun yaxshi yechim emas chunki secretlar ochiq holda turibdi buni Gitlab CI variable yoki Github secretga qo'shiob ishlatishni ko'rib chiqamiz bu amlaiyotda.

Qiziq savol tu'giladi nega ba'zi loyihlarda `application.properties` fayli bor ba'zilarida esa `application.yml` fayli bor?

`application.properties` va `application.yml` o'rtasidagi far quyidagicha:

| Xusuysatlar | `application.properties` | `application.yml` |
| --- | --- | --- |
| Format | Oddiy key=value formatida yoziladi. | YAML formatida, ierarxik struktura ko'rinishida. |
| O'qilish qulayligi | Kichik loyihalar uchun qulay. | Murakkab konfiguratsiyalarda o'qish oson. |
| Profil boshqaruvi | Har bir profil uchun alohida fayl yaratiladi. | Profil boshqaruvi oson va YAML ichida qilinadi. |

Bu misolda `application-dev.properties` va `application-prod.properties` fayllarini alohida yaratish kerak bo'lsa, `application-dev.yml` va `application-prod.yml` fayllarini alohida yaratish kerak emas. YAML formati ierarxik struktura ko'rinishida yoziladi, shuning uchun profil boshqaruvi oson va qulaydir.

```yaml filename="application.yml"
spring:
  profiles:
    active: dev
---
spring:
  profiles: dev
  datasource:
    url: jdbc:postgresql://dev-db-url
---
spring:
  profiles: prod
  datasource:
    url: jdbc:postgresql://prod-db-url
```

Multi environment boshqaruvda application.properties va application.yml fayllarini quyidagicha ishlatamiz.

Masalan bizda `dev`, `stage`, `prod` environmentlar uchun alohida konfiguratsiyalar mavjud bo'lsa, `application-dev.properties`, `application-stage.properties`, `application-prod.properties` fayllarini yaratamiz. Bu fayllar alohida environmentlar uchun kerak bo'lgan konfiguratsiyalarni saqlaydi, agar `application.yml` faylini ishlatishni xohlasak, uni `application-dev.yml`, `application-stage.yml`, `application-prod.yml` yoki bitta `application.yml` faylida yozishimiz mumkin.

CI/CD'da ishga tushirishda esa `docker run -e SPRING_PROFILES_ACTIVE=dev` yoki `docker run -e SPRING_PROFILES_ACTIVE=prod` kabi environmentlar orqali alohida environmentni tanlashimiz mumkin.

## Dockerfile yozish

<Callout type="info" emoji="">
Agar siz Docker bilan tanish bo'lmasangiz quyidagi qo'llanmalar orqali Docker bilan tanishingiz mumkin: [**Dockerga Kirish**](https://devops-journey.uz/guides/konteyner/dockerga-kirish), [**Mastering Docker**](https://devops-journey.uz/guides/konteyner/docker-asoslari), [**Dockerfile yozish**](https://devops-journey.uz/guides/konteyner/dockerfile-yozish), [**Docker o'rnatish**](https://devops-journey.uz/guides/konteyner/docker-ornatish)
</Callout>

Spring Boot applicationni Docker konteyneriga joylash uchun `Dockerfile` yozish kerak. `Dockerfile` fayli konteynerning tuzilishini, ishlash prinsiplarini va muhim konfiguratsiyalarini saqlaydi. Docker orqali applicationlarimizni 

```bash filename="Dockerfile"
FROM maven:3.9.5-eclipse-temurin-17-alpine AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn package -DskipTests -B

FROM eclipse-temurin:17-alpine
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
RUN chown -R appuser:appgroup /app
USER appuser
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD wget --spider --quiet http://localhost:8080/actuator/health || exit 1
ENTRYPOINT ["java", "-jar", "app.jar"]
```

Dockerfileni ko'rib chiqadigan bo'lsa, u quyidagi qadamlardan iborat: 

Dockerfile 2 qismga bo'linadi, build bosqichi(build stage) va runtime bosqichi(runtime stage). builter stageda Maven asosida  loyihani build qilish va kerakli librarylarni yuklab olish uchun ishlatiladi va bunda biz yengil va kichik alpine imagedan foydalanamiz. runtime stageda esa yengil `eclipse-temurin:17-alpine` imajidan foydalanamiz bu Spring Boot uchun eng optimal JDK imagedir. Birinchi bosqich 1-6 qadamlar Maven asosida loyihani build qilish uchun kerakli jar faylini yaratadi. Ikkinchi bosqich 7-14 qadamlar esa jar faylini ishga tushiradi.

1. `FROM maven:3.9.5-eclipse-temurin-17-alpine AS builder` - Maven va Java 17 asosida Docker imageni yaratamiz bu bizning `builder` imagemiz bo'ladi.
2. `WORKDIR /app` - `/app` papkasiga o'tamiz yani barcha ishlarimizni bu papkada amalga oshiramiz.
3. `COPY pom.xml .` - `pom.xml` faylini `/app` papkasiga ko'chiramiz bu faylda Maven dependencylar saqlanadi.
4. `RUN mvn dependency:go-offline -B` - Maven dependencylarini yuklab olamiz va `go-offline` parametri bilan ishga tushiramiz.
5. `COPY src ./src` - `src` katalogini `/app/src` papkasiga ko'chiramiz bu katalogda Java fayllar joylashgan.
6. `RUN mvn package -DskipTests -B` - Spring Boot applicationni jar faylini yaratamiz va testlarni ishga tushirmasdan ishga tushiramiz.
7. `FROM eclipse-temurin:17-alpine` - Java 17 asosida Docker imajini yaratamiz bu bizning asosiy imagemiz bo'ladi.
8. `RUN addgroup -S appgroup && adduser -S appuser -G appgroup` - `appgroup` va `appuser` guruhlarini yaratamiz bu xavfsizlik uchun kerak bo'ladi.
9. `WORKDIR /app` - `/app` papkasiga o'tamiz.
10. `COPY --from=builder /app/target/*.jar app.jar` - `builder` imajidan jar faylini `/app` papkasiga ko'chiramiz bu jar fayl Spring Boot applicationni ishga tushirish uchun kerak bo'ladi.
11. `RUN chown -R appuser:appgroup /app` - `/app` papkasiga `appuser` va `appgroup` guruhlariga ega bo'lgan huquqlarni beramiz
12. `USER appuser` - `appuser` foydalanuvchiga o'tamiz. 
13. `EXPOSE 8080` - 8080 portni ochamiz.
14. `HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \ CMD wget --spider --quiet http://localhost:8080/actuator/health || exit 1` - Spring Boot applicationning `actuator/health` endpointiga HTTP so'rov yuborishni tekshiramiz va 3 marta urinishdan keyin xatolik chiqsa konteynerni qayta ishga tushiramiz.
15. `ENTRYPOINT ["java", "-jar", "app.jar"]` - Spring Boot applicationni ishga tushiramiz.

## Konfiguratsiya fayllari bilan ishlash

Spring Boot applicationni Docker konteyneriga joylashda `application.properties` yoki `application.yml` fayllarini ishlatish kerak bo'ladi. Bu fayllar applicationning konfiguratsiyalarini saqlash uchun kerak bo'ladi. Bizning loyihamizda `application.properties` fayli mavjud lekin unda secretlar ochiq holda shunih uchun secretlarni Gitlab CI variablega qo'shib multi-environment qilib sozlashimiz kerak bo'ladi. `src/main/resources` katalogida `application-dev.properties`va `application-prod.properties` fayllarini yaratamiz va ularni alohida environmentlar uchun kerakli konfiguratsiyalarni saqlaymiz.

`application-dev.properties` faylida dev environment uchun kerakli konfiguratsiyalar saqlanadi.
```properties filename="application-dev.properties"
spring.application.name=waifulist
# DATABASE
spring.datasource.url=${DEV_DATABASE_URL}
spring.datasource.username=${DEV_DATABASE_USERNAME}
spring.datasource.password=${DEV_DATABASE_PASSWORD}
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

logging.level.org.springframework.web=DEBUG
logging.level.org.springdoc=DEBUG
```
`application-prod.properties` faylida esa prod environment uchun kerakli konfiguratsiyalar saqlanadi.
```properties filename="application-prod.properties"
spring.application.name=waifulist
# DATABASE
spring.datasource.url=${PROD_DATABASE_URL}
spring.datasource.username=${PROD_DATABASE_USERNAME}
spring.datasource.password=${PROD_DATABASE_PASSWORD}
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

logging.level.org.springframework.web=DEBUG
logging.level.org.springdoc=DEBUG
```

Environment variablelarni Gitlab CI variablega qo'shib chiqishimiz kerak bo'ladi. Repositoriyaga o'tib **-> Settings -> CI/CD -> Variables** bo'limiga o'tamiz va kerakli environment variablelarni qo'shib chiqamiz.

`DEV_DATABASE_URL` ga `jdbc:postgresql://134.209.217.179:5432/waifulist` formatda secret keyni yozamiz buyerda IP manzil PostgreSQL server manzili va porti `waifulist` esa database nomi bo'ladi.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/1.png)

`DEV_DATABASE_USERNAME` ga `postgres` secret keyni yozamiz buyerda PostgreSQL serverga ulanish uchun kerak bo'lgan foydalanuvchi nomi.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/2.png)
`DEV_DATABASE_PASSWORD` ga `lwfjljqwotpreqwt2` secret keyni yozamiz bu PostgreSQL serverga yuqoria belgilangan user bilan ulanish uchun kerak user paroli(yani `postgres` user paroli).
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/3.png)
Gitlab CI variablega secret keylarni qo'shib chiqdik endi Gitlab CI/CD pipeline'larimizda bu secret keylarni ishlatishimiz mumkin.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/4.png)

## Gitlab CI/CD pipeline

Okey yuqorida biz loyihani tushundik, Dockerfile yozdik va konfiguratsiyalarimizni sozladik endi Gitlab CI/CD pipeline'larimizni yozamiz. Gitlab CI/CD pipeline'larini yozish uchun `.gitlab-ci.yml` faylini loyihaning asosiy katalogiga yaratamiz.

### CI pipeline
Birinchi navbatda loyihani test qilish uchun CI pipeline'ni yozamiz.

```yaml filename=".gitlab-ci.yml"
stages:
  - build_and_push

variables:
  IMAGE_NAME: waifulist
  REPO_NAME: $CI_PROJECT_PATH
  REGISTRY: "registry.gitlab.com"

build_and_push:
  stage: build_and_push
  image: docker:stable

  services:
    - docker:dind

  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

  script:
    - docker build -t $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA .
    - docker push $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA
```
Ushbu CI pipeline'ni tushunish uchun quyidagi qadamlarni ko'rib chiqamiz: 

<Callout type="info" emoji="">
Agar siz Gitlab CI/CD bilan tanish bo'lmasangiz quyidagi qo'llanmalar orqali Gitlab CI/CD bilan tanishingiz mumkin: [**Gitlab CI bilan CI/CD**](https://devops-journey.uz/guides/ci-cd/start-gitlabci), [**Gitlab CI | Releaselar va Integrationlar**](https://devops-journey.uz/guides/ci-cd/gitlab-ci-release-integrations).
</Callout>

1. `stages` - Pipeline'ning bosqichlarini bildiradi bunda faqat `build_and_push` bosqich bor.
2. `variables` - Pipeline'ning ishlatadigan o'zgaruvchilar belgilanadi bu yerda `IMAGE_NAME`, `REPO_NAME`, `REGISTRY` o'zgaruvchilari belgilangan container registry sifatida gitlab container registry ishlatilgan.
3. `build_and_push` - Pipeline'ning birinchi bosqichidir bu bosqichda loyihani build qilish va Gitlab registryga imageni push qilish amalga oshiriladi.
4. `image` - Docker imageni ishlatish uchun `docker:stable` imageni ishlatamiz.
5. `services` - Docker daemonni ishlatish uchun `docker:dind` servisini ishlatamiz.
6. `before_script` - Pipeline boshlanishida Gitlab registryga kirish uchun bajariladigan amallar belgilanadi bu holda `docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY` amalini bajaradi yani Gitlab registryga kiradi.
7. `script` - Docker imageni build qilish va Gitlab registryga push qilish amallari belgilanadi bu holda `docker build -t $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA .` va `docker push $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA` amallari bajariladi.

Bu CI pipeline docker yordamida loyihani build qiladi va Gitlab registryga imageni push qiladi.

`.gilab-ci.yml` faylini yuqoridagidek konfiguratsiya yozib gitlabga push qilamiz va bizda avtomatik CI pipeline ishga tushadi.

![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/12.png)
Ko'k rang bilan ishlab turgan job ustiga bosib CI pipeline'ni ko'rishimiz mumkin  va u ochilganda biz `build_and_push` jobini ko'rishimiz mumkin. Joblar ko'k rangda pipeline ishga tushayotganini bildiradi.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/13.png)

Okey bizning CI pipeline muvaffaqiyatli ishga tushdi va Gitlab registryga imageni push qildik endi uni tekshirib ko'rishimiz kerak bo'ladi.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/14.png)

Repositoriyadagi **-> Deploy -> Container Registry** bo'limiga o'tib CI pipeline orqali build qilingan imageni ko'rishimiz mumkin.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/15.png)
Mana bizning `waifulist` docker imagemiz.
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/16.png)

Bizda CI bosqichini muvaffaqiyatli ishga tushirdik endi esa CD pipeline'ni yozamiz.

### CD pipeline

CD pipelineda biz CI bosqichida build bo'lgan docker imageni Gitlab registrydan olib, ssh orqali vm'ga kirib docker konteynerini ishga tushiramiz. Bu amaliyotda deploy qilish uchun vm(virtual mashina) ishlatamiz vmga docker intsall qilamiz va CD pipelineda serverga kirib docker konteynerini ishga tushiramiz.

Buning uchun `.gitlab-ci.yml` faylini quyidagicha o'zgartiramiz.

```yaml filename=".gitlab-ci.yml" {3,7-8,11-17,30-44}
stages:
  - build_and_push
  - deploy

variables:
  IMAGE_NAME: waifulist
  CONTAINER_NAME: waifulist
  PORT: "8080:8080"
  REPO_NAME: $CI_PROJECT_PATH
  REGISTRY: "registry.gitlab.com"
  SSH_HOST: $SERVER_IP
  SSH_USER: $SERVER_USERNAME
  SSH_KEY: $SSH_PRIVATE_KEY
  SPRING_PROFILES_ACTIVE: dev
  DEV_DATABASE_URL: $DEV_DATABASE_URL
  DEV_DATABASE_USERNAME: $DEV_DATABASE_USERNAME
  DEV_DATABASE_PASSWORD: $DEV_DATABASE_PASSWORD

build_and_push:
  stage: build_and_push
  image: docker:stable
  services:
    - docker:dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
  script:
    - docker build -t "$REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA" .
    - docker push "$REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA"

deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --update --no-cache openssh-client
  script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts 
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY"
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker pull $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA"
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker stop $CONTAINER_NAME || true"
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "docker rm $CONTAINER_NAME || true"
    - ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no "$SSH_USER@$SSH_HOST" "docker run -d --name $CONTAINER_NAME -p $PORT -e SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE -e DEV_DATABASE_URL=$DEV_DATABASE_URL -e DEV_DATABASE_USERNAME=$DEV_DATABASE_USERNAME -e DEV_DATABASE_PASSWORD=$DEV_DATABASE_PASSWORD $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA"
```

Ushbu CD pipeline'ni tushunish uchun quyidagi qadamlarni ko'rib chiqamiz:

1. `stages` - ga `deploy` bosqichini qo'shamiz bu bosqichda loyihani deploy qilish amalga oshiriladi.
2. `variables` - ga yangi o'zgaruvchilar qo'shamiz bu o'zgaruvchilar `CONTAINER_NAME`, `PORT`, `SSH_HOST`, `SSH_USER`, `SSH_KEY`, `SPRING_PROFILES_ACTIVE`, `DEV_DATABASE_URL`, `DEV_DATABASE_USERNAME`, `DEV_DATABASE_PASSWORD` o'zgaruvchilari belgilangan.
3. `deploy` - Pipeline'ning ikkinchi bosqichidir bu bosqichda loyihani deploy qilish amalga oshiriladi bu bosqichda ssh orqali serverga kirib docker konteynerini ishga tushiramiz.
4. `image` - Docker imageni ishlatish uchun `alpine:latest` imageni ishlatamiz.
5. `before_script` - Pipeline boshlanishida `openssh-client`ni o'rnatish uchun bajariladigan amallar belgilanadi.
6. `script` - SSH orqali serverga kirib docker konteynerini ishga tushirish amallari belgilanadi.
7. `mkdir -p ~/.ssh` - `~/.ssh` papkasini yaratamiz bu papkada ssh keylar saqlanadi.
8. `echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa` - SSH private keyni `~/.ssh/id_rsa` fayliga yozamiz bu key serverga kirish uchun kerak bo'ladi.
9. `chmod 600 ~/.ssh/id_rsa` - `~/.ssh/id_rsa` faylining huquqlarini belgilaymiz bu keyga faqat foydalanuvchi o'qishi mumkin.
10. `ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts` - SSH hostning public keyini `~/.ssh/known_hosts` fayliga yozamiz bu hostga birinchi marta ulanishda xatolik chiqmasligi uchun kerak bo'ladi.
11. `ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST " bu amal SSH orqali serverga kirish amaliyotini bajaradi.
12. `echo "$CI_JOB_TOKEN" | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY"` - Gitlab registryga kirish uchun bajariladigan amal buning sababi Gitlab container registryga kirish va CI pipelineda yaratilgan imageni olish uchun kerak bo'ladi.
13. `docker pull $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA` - Gitlab registrydan imageni pull qilib oladi.
14. `docker stop $CONTAINER_NAME || true` - Bu eski Docker konteynerini to'xtatadi.
15. `docker rm $CONTAINER_NAME || true` - Bu eski Docker konteynerini o'chiradi.
16. `docker run -d --name $CONTAINER_NAME -p $PORT -e SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE -e DEV_DATABASE_URL=$DEV_DATABASE_URL -e DEV_DATABASE_USERNAME=$DEV_DATABASE_USERNAME -e DEV_DATABASE_PASSWORD=$DEV_DATABASE_PASSWORD $REGISTRY/$REPO_NAME/$IMAGE_NAME:$CI_COMMIT_SHA` - Bu buyruq esa Gitlab CI pipelineda yaratilgan imageni belgilan variablelar bilan ishga tushiradi, yani belgilangan portda, belgilangan nomda, belgilangan environment variablelar bilan ishga tushiradi.


![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/17.png)
![java-deployment](https://raw.githubusercontent.com/devops-journey-uz/assets/main/images/tutorials/ci-cd/java-deployment/18.png)